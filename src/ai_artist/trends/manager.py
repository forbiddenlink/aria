"""Trend analysis and management."""

import abc
import asyncio
from typing import List, Protocol

import httpx

from ..utils.logging import get_logger

logger = get_logger(__name__)


class TrendProvider(Protocol):
    """Protocol for trend providers."""

    async def get_trending_tags(self, limit: int = 10) -> List[str]:
        """Get trending tags/styles."""
        ...


class CivitAITrendProvider:
    """Fetches trending tags from CivitAI (AI Art specific)."""

    def __init__(self):
        self.base_url = "https://civitai.com/api/v1"
        self.client = httpx.AsyncClient(timeout=10.0)

    async def get_trending_tags(self, limit: int = 20) -> List[str]:
        """Fetch trending tags."""
        try:
            # CivitAI tags endpoint
            response = await self.client.get(
                f"{self.base_url}/tags",
                params={"limit": limit, "sort": "Most Models"}
            )
            response.raise_for_status()
            data = response.json()
            
            # Extract names
            tags = [item["name"] for item in data.get("items", [])]
            logger.info("fetched_civitai_trends", count=len(tags), sample=tags[:3])
            return tags
        except Exception as e:
            logger.error("civitai_trend_fetch_failed", error=str(e))
            return []
            
    async def close(self):
        await self.client.aclose()


class ArtStationTrendProvider:
    """Fetches trending subjects from ArtStation (General Art)."""
    
    def __init__(self):
        self.url = "https://www.artstation.com/api/v2/community/channels/trending.json"
        self.client = httpx.AsyncClient(timeout=10.0, headers={
            "User-Agent": "AIArtist/1.0 (Educational AI Project)"
        })

    async def get_trending_tags(self, limit: int = 20) -> List[str]:
        """Fetch trending categories/channels."""
        try:
            response = await self.client.get(
                self.url,
                params={"page": 1, "per_page": limit}
            )
            response.raise_for_status()
            data = response.json()
            
            # Extract tag names from channels
            tags = [item["name"] for item in data.get("data", [])]
            logger.info("fetched_artstation_trends", count=len(tags), sample=tags[:3])
            return tags
        except Exception as e:
            logger.warning("artstation_trend_fetch_failed", error=str(e))
            return []

    async def close(self):
        await self.client.aclose()


class TrendManager:
    """Manages trend sourcing and updating."""

    def __init__(self):
        self.providers: List[TrendProvider] = [
            CivitAITrendProvider(),
            ArtStationTrendProvider()
        ]

    async def get_combined_trends(self, limit: int = 50) -> List[str]:
        """Get unique trending tags from all sources."""
        all_tags = set()
        
        # Gather execution
        tasks = [p.get_trending_tags(limit=limit) for p in self.providers]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for res in results:
            if isinstance(res, list):
                all_tags.update(res)
        
        # Clean tags (remove problematic chars, lowercase)
        cleaned = {t.lower().strip() for t in all_tags if t and len(t) > 2}
        
        # Filter out common boring words if needed
        blacklist = {"concept art", "digital art", "character", "base model"}
        final_tags = sorted(list(cleaned - blacklist))
        
        logger.info("trends_aggregated", total=len(final_tags))
        return final_tags

    async def update_wildcard_file(self, filepath: str = "config/wildcards/trending.txt"):
        """Update a wildcard file with current trends."""
        tags = await self.get_combined_trends()
        if not tags:
            logger.warning("no_trends_found_skipping_update")
            return
            
        try:
            from pathlib import Path
            path = Path(filepath)
            path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(path, "w", encoding="utf-8") as f:
                f.write("# Generated by TrendManager\n")
                f.write("\n".join(tags))
                
            logger.info("trending_wildcard_updated", path=filepath, count=len(tags))
        except Exception as e:
            logger.error("trend_file_update_failed", error=str(e))

    async def close(self):
        for p in self.providers:
            if hasattr(p, "close"):
                await p.close()
